import { scheduleEvents, type ScheduleEvent, type NewScheduleEvent } from '@/lib/db/schema'
import { eq, and, inArray } from 'drizzle-orm'
import { createDB } from '@/lib/db/client'

export class ScheduleEventsService {
  private _db: any

  private get db() {
    if (!this._db) {
      this._db = createDB()
    }
    return this._db
  }

  /**
   * 일정 이벤트 생성
   */
  async create(data: NewScheduleEvent): Promise<ScheduleEvent | null> {
    try {
      const [event] = await this.db
        .insert(scheduleEvents)
        .values(data)
        .returning()

      return event || null
    } catch (error) {
      console.error('ScheduleEventsService.create error:', error)
      return null
    }
  }

  /**
   * 날짜와 타입으로 조회
   */
  async findByDateAndType(date: string, type: string): Promise<ScheduleEvent[]> {
    try {
      return await this.db
        .select()
        .from(scheduleEvents)
        .where(
          and(
            eq(scheduleEvents.date, date),
            eq(scheduleEvents.type, type)
          )
        )
    } catch (error) {
      console.error('ScheduleEventsService.findByDateAndType error:', error)
      return []
    }
  }

  /**
   * 날짜 범위로 조회
   */
  async findByDateRange(dates: string[]): Promise<ScheduleEvent[]> {
    try {
      if (dates.length === 0) return []
      
      return await this.db
        .select()
        .from(scheduleEvents)
        .where(inArray(scheduleEvents.date, dates))
    } catch (error) {
      console.error('ScheduleEventsService.findByDateRange error:', error)
      return []
    }
  }

  /**
   * 자동 생성된 이벤트 조회
   */
  async findAutoGeneratedByDateAndType(
    date: string, 
    type: string, 
    sourceType?: string
  ): Promise<ScheduleEvent | null> {
    try {
      let conditions = [
        eq(scheduleEvents.date, date),
        eq(scheduleEvents.type, type),
        eq(scheduleEvents.isAutoGenerated, true)
      ]

      if (sourceType) {
        conditions.push(eq(scheduleEvents.sourceType, sourceType))
      }

      const [event] = await this.db
        .select()
        .from(scheduleEvents)
        .where(and(...conditions))
        .limit(1)

      return event || null
    } catch (error) {
      console.error('ScheduleEventsService.findAutoGeneratedByDateAndType error:', error)
      return null
    }
  }

  /**
   * 이벤트 업데이트
   */
  async update(id: string, data: Partial<ScheduleEvent>): Promise<ScheduleEvent | null> {
    try {
      const [event] = await this.db
        .update(scheduleEvents)
        .set(data)
        .where(eq(scheduleEvents.id, id))
        .returning()

      return event || null
    } catch (error) {
      console.error('ScheduleEventsService.update error:', error)
      return null
    }
  }

  /**
   * 이벤트 삭제
   */
  async delete(id: string): Promise<boolean> {
    try {
      await this.db
        .delete(scheduleEvents)
        .where(eq(scheduleEvents.id, id))

      return true
    } catch (error) {
      console.error('ScheduleEventsService.delete error:', error)
      return false
    }
  }

  /**
   * 조건별 삭제 (자동 생성된 이벤트 정리 등)
   */
  async deleteByCondition(
    date: string,
    type: string,
    isAutoGenerated: boolean,
    sourceType?: string
  ): Promise<number> {
    try {
      let conditions = [
        eq(scheduleEvents.date, date),
        eq(scheduleEvents.type, type),
        eq(scheduleEvents.isAutoGenerated, isAutoGenerated)
      ]

      if (sourceType) {
        conditions.push(eq(scheduleEvents.sourceType, sourceType))
      }

      const result = await this.db
        .delete(scheduleEvents)
        .where(and(...conditions))

      return result.changes || 0
    } catch (error) {
      console.error('ScheduleEventsService.deleteByCondition error:', error)
      return 0
    }
  }
}