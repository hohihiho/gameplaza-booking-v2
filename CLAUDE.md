# 광주 게임플라자 예약 시스템 - 에이전트 룰

이 프로젝트는 여러 전문가 에이전트가 협업하여 개발합니다. 각 에이전트는 자신의 전문 분야에서 최고의 결과를 만들어야 합니다.

## 🤖 에이전트 시스템

### 에이전트 파일 구조
각 전문가 에이전트는 별도 파일로 관리되어 필요시 로드됩니다:
```
/docs/agents/
  ├── frontend-developer.md    # React/TypeScript 전문가
  ├── backend-developer.md      # Supabase/API 전문가
  ├── ui-ux-designer.md        # 디자인/UX 전문가
  ├── security-expert.md       # 보안 전문가
  ├── data-analyst.md          # 데이터 분석가
  ├── qa-engineer.md           # 품질 보증 엔지니어
  ├── code-quality.md          # 코드 품질 전문가
  ├── devops.md               # 배포/운영 전문가
  └── project-manager.md       # 프로젝트 매니저
```

### 에이전트 활성화 방법
작업에 따라 필요한 에이전트를 호출하여 전문적인 도움을 받으세요:

1. **특정 에이전트 호출**
   - "Frontend Developer 에이전트로 이 컴포넌트 검토해줘"
   - "Security Expert 관점에서 이 코드 분석해줘"
   - "QA Engineer로서 테스트 시나리오 작성해줘"

2. **다중 에이전트 협업**
   - "Frontend와 Backend 에이전트가 함께 API 설계해줘"
   - "모든 에이전트가 이 기능 검토해줘"

3. **자동 활성화 조건**
   - 각 에이전트는 특정 키워드나 작업 유형에 따라 자동 활성화
   - 예: React 코드 작성 시 Frontend Developer 자동 활성화

## 🎯 공통 원칙

1. **모바일 퍼스트**: 모든 결정은 모바일 사용자(99%)를 우선으로
2. **성능 최적화**: 3G 환경에서도 빠른 로딩 속도 보장
3. **접근성**: WCAG 2.1 AA 기준 준수
4. **실시간성**: 예약/기기 상태는 항상 실시간 동기화
5. **한국어 우선**: 모든 커밋 메시지, 주석, 문서는 한국어로 작성
6. **시간대 KST 고정**: 모든 시간 처리는 반드시 KST(한국 표준시) 기준으로만 처리
   - JavaScript Date 객체 생성 시 UTC 파싱 금지
   - 날짜 문자열은 로컬 시간대로 파싱
   - 서버/클라이언트 모두 KST 기준 통일
   - 예: `new Date("2025-07-01")` ❌ → `new Date(2025, 6, 1)` ✅
7. **24시간 표시 체계**: 익일 새벽 시간(0~5시)은 24~29시로 표시
   - 밤샘 시간대의 연속성을 위해 0~5시는 24~29시로 표시
   - 예: 00:00 → 24시, 02:00 → 26시, 05:00 → 29시
   - 모든 시간 표시에서 일관되게 적용
   - 24시간 제한 계산 시에도 정확한 시간 계산 필수
8. **개발 서버 포트**: 항상 3000번 포트만 사용
   - npm run dev 실행 전 3000번 포트가 사용 중이면 `lsof -ti:3000 | xargs kill -9`로 종료
   - 다른 포트 사용 금지 (3001, 3002 등 사용하지 않음)
9. **단순성 최우선**: "단순함이 답이다" - 모든 구현은 가능한 한 단순하게
   - 복잡한 추상화보다 명확한 코드
   - 과도한 최적화보다 읽기 쉬운 코드
   - 큰 변경보다 작은 점진적 개선
   - YAGNI (You Aren't Gonna Need It) 원칙 준수

## 📋 전문가 에이전트 목록

각 에이전트의 상세 규칙과 가이드라인은 `/docs/agents/` 디렉토리의 개별 파일을 참조하세요:

- **Frontend Developer Agent** → `/docs/agents/frontend-developer.md`
- **Backend Developer Agent** → `/docs/agents/backend-developer.md`
- **UI/UX Designer Agent** → `/docs/agents/ui-ux-designer.md`
- **Security Expert Agent** → `/docs/agents/security-expert.md`
- **Data Analyst Agent** → `/docs/agents/data-analyst.md`
- **QA Engineer Agent** → `/docs/agents/qa-engineer.md`
- **Code Quality Agent** → `/docs/agents/code-quality.md`
- **DevOps Agent** → `/docs/agents/devops.md`
- **Project Manager Agent** → `/docs/agents/project-manager.md`

## 🤝 협업 규칙

1. **커밋 규칙**
   ```
   [타입] 제목
   
   본문 (선택)
   
   타입: feat|fix|docs|style|refactor|test|chore
   ```

2. **브랜치 전략**
   - main: 프로덕션
   - develop: 개발
   - feature/*: 기능 개발
   - hotfix/*: 긴급 수정

3. **코드 리뷰**
   - 모든 PR은 리뷰 필수
   - 테스트 통과 필수
   - 2명 이상 승인
   - 24시간 내 리뷰

4. **문서화**
   - README 최신 유지
   - API 문서 자동 생성
   - 주요 결정 사항 기록
   - 트러블슈팅 가이드

## 🧠 메타 인지 프레임워크

### AI 협업 핵심 원칙
AI는 시니어 엔지니어의 대체가 아닌 협업 도구입니다:

1. **능동적인 인간 감독**
   - AI의 계획과 제안을 비판적으로 검토
   - 부적절한 방향은 즉시 중단
   - 생성된 코드는 반드시 철저히 테스트
   - 모든 솔루션을 의심하고 검증

2. **AI 작업 모니터링**
   - AI의 사고 과정을 실시간으로 추적
   - 과도하게 복잡한 구현 방지
   - 기술 부채 누적 차단
   - 자신감 있지만 잘못된 솔루션 주의

### 문제 해결 프로토콜
모든 에이전트는 다음의 체계적인 접근법을 따라야 합니다:

1. **탐색 (Explore)**
   - 문제의 전체 맥락 파악
   - 관련 코드베이스 조사
   - 기존 솔루션 및 패턴 분석
   - 제약 조건 및 요구사항 명확화

2. **계획 (Plan)**
   - 단계별 해결 전략 수립
   - 잠재적 위험 요소 식별
   - 대안 시나리오 준비
   - 성공 기준 정의

3. **구현 (Implement)**
   - 점진적이고 반복적인 개발
   - 각 단계마다 검증
   - 코드 품질 기준 준수
   - 지속적인 피드백 반영

4. **검증 (Verify)**
   - 단위 테스트 작성 및 실행
   - 통합 테스트 수행
   - 성능 및 보안 검증
   - 사용자 시나리오 테스트

### 인지적 체크포인트
각 주요 작업 단계에서 다음을 확인:
- ✅ 요구사항과 일치하는가?
- ✅ 기존 코드베이스와 일관성이 있는가?
- ✅ 성능/보안 기준을 충족하는가?
- ✅ 테스트 가능하고 유지보수가 용이한가?
- ✅ AI가 과도하게 복잡한 솔루션을 제안하지 않았는가?
- ✅ 기술 부채를 만들지 않는가?

## 🔄 표준 워크플로우

### 1. 테스트 주도 개발 워크플로우 ⭐
모든 개발 작업은 다음 순서를 따라야 합니다:

1. **요구사항 분석**
   - 비즈니스 요구사항 명확화
   - 테스트 시나리오 도출
   - 예상되는 엣지 케이스 파악

2. **테스트 작성**
   - 단위 테스트 먼저 작성 (TDD)
   - 통합 테스트 계획 수립
   - 테스트 커버리지 목표 설정 (최소 80%)

3. **구현**
   - 테스트를 통과하는 최소한의 코드 작성
   - 리팩토링으로 코드 품질 개선
   - 성능 최적화

4. **테스트 실행 및 검증**
   - 모든 테스트 통과 확인
   - 커버리지 분석
   - 성능 측정

5. **테스트 결과 문서화** 🔴 필수
   - `/docs/test-results/` 디렉토리에 결과 기록
   - 파일명: `{기능명}-tests.md`
   - 포함 내용:
     - 테스트 개요 및 범위
     - 커버리지 수치
     - 테스트 케이스 목록
     - 주요 검증 포인트
     - 발견된 이슈 및 해결
     - 향후 개선 사항
   - 예시: `/docs/test-results/time-slot-system-tests.md`

6. **코드 리뷰 및 머지**
   - PR에 테스트 결과 링크 포함
   - 테스트 커버리지 스크린샷 첨부
   - 리뷰어가 테스트 결과 확인

### 2. Claude Code 7가지 규칙
모든 개발 작업은 다음 7가지 규칙을 따라야 합니다:

1. **충분한 사전 분석**
   - 문제를 충분히 이해하고 분석
   - 관련 파일의 코드베이스 철저히 읽기
   - `/docs/tasks/todo.md`에 상세한 계획 작성

2. **체크 가능한 할 일 목록**
   - 명확하고 측정 가능한 작업 항목
   - 각 항목은 완료 시 체크 표시 가능
   - 우선순위와 예상 시간 포함

3. **계획 검증**
   - 작업 시작 전 계획 검토 요청
   - 팀원 또는 리더의 피드백 반영
   - 필요시 계획 수정 및 보완

4. **진행 상황 추적**
   - 작업 시작 시 할 일 항목을 "진행 중"으로 표시
   - 완료 시 즉시 "완료"로 업데이트
   - 실시간 진행 상황 공유

5. **변경 사항 문서화**
   - 모든 단계에서 변경 내용 간략히 설명
   - 왜 이런 변경을 했는지 명시
   - 영향 범위 명확히 기록

6. **단순성 최우선 원칙**
   - 가능한 한 간단하게 구현
   - 대규모 또는 복잡한 변경 피하기
   - 코드에 미치는 영향 최소화
   - "단순함이 답이다" 철학 준수

7. **검토 섹션 작성**
   - `todo.md`에 변경 사항 요약
   - 배운 점과 개선 사항 기록
   - 다음 단계 제안 포함

### 2. Explore-Plan-Code-Commit (EPCC) 워크플로우
```
탐색 → 계획 → 코딩 → 커밋
│      │      │      │
└──────┴──────┴──────┘
      피드백 루프
```

**단계별 가이드:**
1. **Explore (탐색)**
   - 관련 파일 검색 및 분석
   - 비즈니스 로직 이해
   - 기술적 제약사항 파악

2. **Plan (계획)**
   - 작업을 작은 단위로 분해
   - 각 단계의 검증 방법 정의
   - 예상 소요 시간 산정

3. **Code (코딩)**
   - TDD 접근법 우선
   - 작은 단위로 커밋
   - 지속적인 리팩토링

4. **Commit (커밋)**
   - 의미 있는 커밋 메시지
   - 관련 이슈 연결
   - CI/CD 파이프라인 확인

### 2. AI 코딩 워크플로우 단계
효과적인 AI 협업을 위한 단계별 프로세스:

1. **컨텍스트 초기화**
   - 작업 시작 전 명확한 컨텍스트 설정
   - 프로젝트 구조와 규칙 공유
   - 도메인 용어 정의

2. **기대치 설정**
   - 베스트 프랙티스 명시
   - 코딩 표준 공유
   - 테스트 요구사항 정의

3. **사용자 스토리 논의**
   - 요구사항을 단순하고 명확하게
   - 복잡한 기능은 작은 단위로 분해
   - 성공 기준 명확화

4. **구현 계획**
   - 코드베이스 일관성 분석
   - 단계별 구현 전략
   - 리스크 사전 식별

5. **코드 생성**
   - TDD 접근법 우선
   - 단순하고 테스트 가능한 함수
   - 타입 안전성 준수

6. **비판적 검토**
   - "의심 많은 시니어 엔지니어" 관점
   - 모든 생성 코드 철저히 검증
   - 복잡도와 유지보수성 평가

7. **포괄적 테스트**
   - UX 시나리오 테스트
   - 엣지 케이스 검증
   - 성능 및 보안 테스트

8. **구조화된 커밋**
   - 명확한 커밋 메시지
   - 관련 이슈 연결
   - 변경 사항 문서화

### 3. 테스트 주도 개발 (TDD) 프로토콜
```
Red → Green → Refactor
│     │       │
실패   성공   개선
```

**구현 순서:**
1. 테스트 먼저 작성 (실패하는 테스트)
2. 최소한의 코드로 테스트 통과
3. 코드 품질 개선 및 리팩토링
4. 모든 테스트 재실행

### 4. 반복적 UI 개발 워크플로우
1. **와이어프레임** → **프로토타입** → **구현** → **최적화**
2. 각 단계마다 사용자 피드백 수집
3. 접근성과 성능을 처음부터 고려

## 🔄 자기 개선 프로토콜

### 학습 로그
각 스프린트 종료 시 다음 항목 기록:
- 🎯 달성한 목표
- 🚧 직면한 도전과제
- 💡 배운 교훈
- 🔧 개선할 프로세스

### 지속적 개선 메커니즘
1. **주간 회고**
   - 무엇이 잘 되었나?
   - 무엇을 개선할 수 있나?
   - 다음 주 액션 아이템은?

2. **기술 부채 추적**
   - 임시 해결책 문서화
   - 리팩토링 우선순위 설정
   - 정기적인 코드 품질 리뷰

3. **베스트 프랙티스 업데이트**
   - 새로 발견한 패턴 문서화
   - 팀 전체와 지식 공유
   - CLAUDE.md 지속적 개선

## 🎯 컨텍스트 관리 전략

### 대규모 작업 시 컨텍스트 유지
1. **작업 세션 시작**
   - 현재 상태 스냅샷
   - 목표 및 제약사항 명시
   - 관련 파일 목록 작성

2. **진행 중 체크포인트**
   - 주요 결정사항 기록
   - 변경된 파일 추적
   - 미완료 작업 표시

3. **작업 중단/재개**
   - 상태 요약 문서 작성
   - 다음 단계 명확히 정의
   - 컨텍스트 복원 체크리스트

### 효과적인 문서화
- 왜(Why) → 무엇을(What) → 어떻게(How) 순서로 기록
- 코드 주석은 '왜'에 집중
- README는 빠른 시작 가이드 중심

## 🚀 개발 순서

1. **Phase 1: 기초 설정** (Frontend + Backend + DevOps)
2. **Phase 2: 인증 시스템** (Backend + Security)
3. **Phase 3: 예약 시스템** (Frontend + Backend + UI/UX)
4. **Phase 4: 관리자 시스템** (Frontend + Backend + Data)
5. **Phase 5: 테스트 및 최적화** (QA + DevOps)
6. **Phase 6: 배포 및 모니터링** (DevOps + Data)

## 📦 버전 관리

프로젝트는 Semantic Versioning을 따릅니다:
- **MAJOR.MINOR.PATCH** 형식 (예: 1.0.0)
- 상세 규칙은 `/docs/RELEASE_VERSION_GUIDE.md` 참조
- 모든 릴리즈는 Git 태그와 GitHub Release 생성
- CHANGELOG.md 업데이트 필수

## 📝 주의사항

- 각 에이전트는 자신의 전문 분야에 집중하되, 다른 에이전트와 긴밀히 협업
- 결정 사항은 문서화하고 팀 전체와 공유
- 사용자 피드백을 최우선으로 반영
- 매일 진행 상황 업데이트

## 📌 사용자 요청 문서화 규칙

### 중요: 모든 사용자 요청은 별도 문서에 기록합니다
- 위치: `/docs/USER_REQUESTS.md`
- 새로운 요청을 받으면 먼저 해당 문서에서 중복 확인
- 구현 완료 후 반드시 문서 업데이트
- CLAUDE.md는 프로젝트 규칙과 가이드라인만 포함

## 🔄 기획서 자동 업데이트 Hook

### 실행 조건
사용자 요청이 다음 중 하나에 해당하면 기획서 업데이트 필요:
1. **새로운 기능 추가**: 기존에 없던 기능이 구현됨
2. **기존 기능 변경**: 동작 방식, UI/UX, 프로세스 변경
3. **용어 변경**: 화면에 표시되는 텍스트나 기능명 변경
4. **정책 변경**: 가격, 시간, 제한 등 비즈니스 로직 변경

### 업데이트 대상 문서
- `/docs/planning/complete_specification.md` - 전체 기획서
- `/docs/planning/detailed_plan.md` - 상세 기획서 (필요시)
- 기타 관련 문서

### 업데이트 프로세스
1. **변경사항 파악**: 구현된 내용이 기획서와 다른지 확인
2. **섹션 찾기**: 관련된 기획서 섹션 검색
3. **내용 수정**: 
   - 기존 내용이 있으면 수정
   - 없으면 적절한 위치에 추가
4. **버전 업데이트**: 문서 버전과 변경 이력 기록

### 주의사항
- 단순 버그 수정은 기획서 업데이트 불필요
- UI 텍스트나 프로세스 변경은 반드시 업데이트
- 업데이트 시 간결하고 명확하게 작성
- 구현과 기획의 일치성 유지

## 🔐 보안 검토 체크리스트

### 코드 작성 후 필수 검토 사항
모든 코드 변경 후 다음 항목을 반드시 확인:

1. **민감 정보 노출 방지**
   - [ ] API 키, 비밀번호가 코드에 하드코딩되지 않았는가?
   - [ ] 환경 변수가 적절히 사용되었는가?
   - [ ] 로그에 민감한 정보가 출력되지 않는가?
   - [ ] 에러 메시지에 시스템 정보가 노출되지 않는가?

2. **입력값 검증**
   - [ ] 모든 사용자 입력이 검증되는가?
   - [ ] SQL Injection 방지가 되어 있는가?
   - [ ] XSS 방지가 되어 있는가?
   - [ ] 파일 업로드 시 확장자와 크기 검증이 있는가?

3. **인증/인가**
   - [ ] 적절한 권한 검사가 이루어지는가?
   - [ ] 세션 관리가 안전한가?
   - [ ] CSRF 토큰이 사용되는가?
   - [ ] Rate Limiting이 적용되었는가?

4. **데이터 보호**
   - [ ] 개인정보가 암호화되어 저장되는가?
   - [ ] HTTPS가 강제되는가?
   - [ ] 쿠키에 Secure, HttpOnly 플래그가 설정되었는가?
   - [ ] CORS 정책이 적절히 설정되었는가?

## 📚 학습과 지식 공유

### 코드 리뷰 시 교육적 접근
"선임 엔지니어처럼 가르치기" 원칙:

1. **변경 사항 설명**
   - 무엇을 변경했는지 명확히 설명
   - 왜 이런 방식을 선택했는지 근거 제시
   - 다른 대안과 비교 설명

2. **작동 원리 교육**
   - 코드의 흐름을 단계별로 설명
   - 사용된 패턴이나 기술의 개념 설명
   - 실제 예시를 통한 이해도 향상

3. **베스트 프랙티스 공유**
   - 업계 표준과 비교
   - 성능, 보안, 유지보수 관점 설명
   - 참고 자료 및 문서 링크 제공

4. **실수에서 배우기**
   - 자주 발생하는 실수 패턴 공유
   - 디버깅 과정 상세 설명
   - 예방 방법 제시

### AI 코딩 실전 팁
1. **모드 전환 전략**
   - "normal mode"로 시작하여 신뢰 구축
   - "auto accept" 모드는 신중하게 전환
   - 실시간으로 작업 트리 모니터링

2. **AI 함정 회피**
   - 과도하게 자신감 있는 답변 주의
   - 불필요하게 복잡한 구현 거부
   - 명확하지 않은 코드는 재작성 요구
   - 기술 부채 생성 방지

3. **효과적인 프롬프팅**
   - 명확하고 구체적인 요구사항 전달
   - 도메인 용어 일관되게 사용
   - 제약 조건과 가정 명시
   - 예시와 반례 제공

### 지속적 학습 문화
- 주간 기술 공유 세션
- 코드 리뷰를 통한 상호 학습
- 새로운 기술 스택 도입 시 팀 교육
- 실패 사례 공유 및 개선 방안 논의
- AI 도구 활용 경험 공유

## 🧠 세션 지속성 및 메모리 관리

### 클로드 코드 재시작 시 프로토콜

#### 🔄 세션 복원 체크리스트
클로드 코드를 재시작한 후 반드시 다음 순서로 진행:

1. **상태 파일 확인** 
   ```
   "현재 프로젝트 상태를 SESSION_STATE.md에서 확인해줘"
   ```

2. **진행 중인 작업 확인**
   ```
   TaskMaster로 현재 진행 중인 작업 목록 확인
   ```

3. **컨텍스트 복원**
   - 기획서(`/docs/planning/complete_specification.md`) 재검토
   - 최근 사용자 요청(`/docs/USER_REQUESTS.md`) 확인
   - 현재 git 상태 파악

#### 📄 핵심 상태 문서들

1. **`/docs/SESSION_STATE.md`** - 현재 세션 상태 (가장 중요)
   - 마지막 작업 내용
   - 진행 중인 작업 목록
   - MCP 도구 설정 상태
   - 다음 해야 할 작업

2. **`/CLAUDE.md`** - 프로젝트 룰과 가이드라인
   - 개발 원칙 및 제약사항
   - 에이전트 시스템 규칙
   - 워크플로우 프로토콜

3. **`/docs/USER_REQUESTS.md`** - 모든 사용자 요청 기록
   - 요청 날짜 및 내용
   - 구현 상태
   - 관련 커밋

#### 🔧 상태 업데이트 의무사항

**작업 완료 시**:
- `SESSION_STATE.md` 업데이트
- TaskMaster에서 작업 완료 처리
- 필요시 기획서 동기화

**새로운 기능 추가 시**:
- 기획서 업데이트
- `USER_REQUESTS.md`에 요청 기록
- 관련 문서 링크 연결

**설정 변경 시**:
- MCP 도구 상태 기록
- 환경 설정 백업

#### 💡 메모리 지속성 팁

1. **중요한 결정사항은 즉시 문서화**
   - 왜 이런 방식을 선택했는지
   - 어떤 대안을 검토했는지
   - 향후 주의사항

2. **작업 중단 시 상태 저장**
   - 현재까지 진행 상황
   - 다음에 해야 할 구체적 단계
   - 참고할 파일들

3. **정기적 상태 동기화**
   - 주요 마일스톤마다 문서 업데이트
   - git 커밋과 문서 상태 일치 확인

### 🎯 빠른 컨텍스트 복원 명령어

클로드 코드 재시작 후 즉시 실행:

```bash
# 1. 현재 상태 확인
"SESSION_STATE.md 파일을 읽고 현재 프로젝트 상태를 요약해줘"

# 2. 작업 목록 확인  
"TaskMaster로 진행 중인 작업들을 보여줘"

# 3. 최근 변경사항 확인
"git status와 최근 커밋들을 확인해줘"

# 4. 다음 단계 계획
"중단된 지점부터 다음에 해야 할 작업을 계획해줘"
```

## 🚀 슬래시 명령어 시스템

### 명령어 개요
슬래시 명령어는 반복적인 작업을 표준화하고 자동화하기 위한 도구입니다. `/명령어` 형식으로 사용하며, 각 명령어는 특정 워크플로우를 실행합니다.

### 📂 프로젝트 관리 명령어

#### `/prime` - 프로젝트 컨텍스트 로드
전체 프로젝트 상태를 빠르게 파악하고 작업 환경을 설정합니다.
```bash
# 실행 순서:
1. SESSION_STATE.md 확인
2. TaskMaster 작업 목록 조회
3. 기획서 최신 상태 확인
4. git 상태 파악
5. 다음 작업 제안
```

#### `/status` - 현재 상태 스냅샷
현재 프로젝트의 전반적인 상태를 요약 보고합니다.
```bash
# 포함 내용:
- 진행 중인 작업
- 최근 변경사항
- 해결 필요한 이슈
- 다음 우선순위 작업
```

#### `/continue` - 작업 재개
중단된 작업을 식별하고 정확한 지점부터 재개합니다.
```bash
# 실행 내용:
- 마지막 작업 내용 복원
- 중단 시점 컨텍스트 로드
- 다음 단계 명확화
```

### 🔧 개발 도구 명령어

#### `/debug` - 디버깅 모드
현재 문제를 체계적으로 분석하고 해결책을 제시합니다.
```bash
# 포함 기능:
- 에러 로그 분석
- 코드 플로우 추적
- 의존성 충돌 검사
- 성능 병목 지점 식별
```

#### `/test` - 테스트 실행 및 분석
테스트를 실행하고 결과를 분석하여 개선점을 제안합니다.
```bash
# 실행 순서:
1. 현재 테스트 상태 확인
2. 테스트 실행 (npm test, jest 등)
3. 실패 케이스 분석
4. 누락된 테스트 케이스 식별
5. 테스트 개선 제안
```

#### `/review` - 코드 리뷰 모드
시니어 엔지니어 관점에서 코드를 체계적으로 리뷰합니다.
```bash
# 리뷰 기준:
- 코드 품질 및 가독성
- 성능 최적화 가능성
- 보안 취약점 검사
- 아키텍처 일관성
- 베스트 프랙티스 준수
```

### 🎮 게임플라자 특화 명령어

#### `/reservation` - 예약 시스템 전문 모드
예약 시스템 관련 작업에 특화된 에이전트 모드를 활성화합니다.
```bash
# 전문 영역:
- KST 시간대 처리
- 24시간 표시 체계 (24~29시)
- 실시간 동기화
- 예약 상태 관리
- 충돌 방지 로직
```

#### `/mobile-check` - 모바일 최적화 검증
모바일 퍼스트 원칙에 따른 최적화 상태를 점검합니다.
```bash
# 검증 항목:
- 모바일 UI/UX 최적화
- 3G 환경 성능
- 터치 인터페이스 적합성
- 반응형 디자인
- 접근성 (WCAG 2.1 AA)
```

#### `/kst-time` - 시간대 처리 검증
KST 시간대 처리가 올바르게 구현되었는지 확인합니다.
```bash
# 검증 내용:
- Date 객체 생성 방식
- 시간대 변환 로직
- 24시간 표시 체계
- 서버-클라이언트 시간 동기화
```

### 👥 에이전트 활성화 명령어

#### `/agent-frontend` - Frontend 전문가 모드
React/TypeScript 전문가로서 프론트엔드 작업을 수행합니다.

#### `/agent-backend` - Backend 전문가 모드
Supabase/API 전문가로서 백엔드 작업을 수행합니다.

#### `/agent-security` - Security 전문가 모드
보안 전문가 관점에서 코드와 시스템을 검토합니다.

#### `/agent-mobile-ux` - Mobile UX 전문가 모드
모바일 사용자 경험 최적화에 특화된 전문가 모드입니다.

### 🔄 자동화 명령어

#### `/commit` - 스마트 커밋
현재 변경사항을 분석하여 적절한 커밋 메시지와 함께 커밋합니다.
```bash
# 실행 과정:
1. git status 및 diff 분석
2. 변경 사항 분류 및 요약
3. 커밋 메시지 생성 (한국어)
4. 관련 이슈 연결
5. 커밋 실행
```

#### `/create-pr` - PR 생성
현재 브랜치의 변경사항을 분석하여 PR을 생성합니다.
```bash
# 포함 내용:
- 변경사항 요약
- 테스트 계획
- 리뷰 포인트
- 관련 이슈 링크
```

### 📋 사용법 예시

```bash
# 작업 시작 시
/prime

# 문제 발생 시
/debug

# 모바일 기능 개발 시
/agent-mobile-ux

# 예약 기능 작업 시
/reservation

# 작업 완료 시
/test
/review
/commit
```

### 🚨 주의사항

1. **명령어 실행 전 확인**: 각 명령어는 특정 작업 모드를 활성화하므로, 현재 상황에 적합한지 확인 후 사용
2. **에이전트 모드 전환**: 다른 에이전트 모드로 전환할 때는 이전 작업을 완료하고 전환
3. **프로젝트 특화**: 이 명령어들은 게임플라자 프로젝트에 특화되어 있으므로 다른 프로젝트에서는 적절히 수정 필요

---

이 룰을 준수하여 최고의 예약 시스템을 만들어냅시다! 🎮